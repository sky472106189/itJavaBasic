package com.itpw.day09.array;

/*
    数据为什么查找速度快？
        1、元素的内存地址是连续的
        2、元素类型相同，所以占用空间大小一样
        3、其实就是408组成原理的一些大题分析。
        4、知道数组占用空间大小，又内存地址是连续的，很容易根据第i个元素，
           让[i * 元素类型大小 = 存放地址] 快速找到。这也是随机存取特性

        随机存取：随机存取就是直接存取，可以通过下标直接访问到元素的位置，与存储位置无关，
        时间复杂度永远为O(1)，例如数组。存取第N个数据时，不需要访问前（N-1）个数据，
        直接就可以对第N个数据操作

    优点：数组的时间局部性和空间局部性好（这个只能说是优点，不能说是查找速度快）
          时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行;
                      如果某数据被访问过，不久以后该数据可能再次被访问。
                      产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。
          空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，
                      即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、
                      顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。

    缺点:1、新增和删除元素效率低，远不如链表，但是对最后一个元素的增删时间复杂度O(1)。
         2、难以存放大容量数据，这是因为在内存中很难找到一大片连续的内存空间。

         补充：操作系统的内存中有很多优化就是为了避免某个进程占用过多的连续内存空间。
         比如页式存储，段式存储，和段页式存储。所以数据这种占用连续的地址太多的情况
         是操作系统不想看到的。我们也要尽量避免。
*/
public class ArrayDemo01 {
    public static void main(String[] args) {
        int[] array1 = {100, 5, 23, 56, 1, 10};
        Person[] array2 = new Person[2];
        array2[0] = new Person();
        array2[1] = new Person();
    }
}

class Person {
}
